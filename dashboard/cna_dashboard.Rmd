---
title: "CNA dashboard"
output: 
  flexdashboard::flex_dashboard:
    vertical_layout: fill
    theme: default
    logo: navin_lab_logo.png
params:
  directory: 
    value: x
  outdir: y
editor_options: 
  chunk_output_type: console
---

``` {js}
// Inverse color of navigation bar.
$('.navbar-inverse').removeClass('navbar-inverse').addClass('navbar-default');
```


```{r setup, include=FALSE, message=FALSE}
# checking for packages, loading or installing
packages <- c("tidyverse", "fs", "shiny",
              "here", "flexdashboard", "cowplot",
              "janitor", "ape", "ggsci", "plotly",
              "amap", "paletteer", "scales", "umap","uwot",
              "flsa", "BiocManager", "DT", "devtools", "Metrics")

package.check <- lapply(packages, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    install.packages(x, dependencies = TRUE,repos = "http://cran.us.r-project.org")
    suppressWarnings(library(x, character.only = TRUE))
  }
})

bioc_packages <- c("ggtree", "ComplexHeatmap")

lapply(bioc_packages, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    BiocManager::install(x, update = FALSE)
    suppressWarnings(library(x, character.only = TRUE))
  }
})

git_packages<- c("Rphenograph")
lapply(git_packages, FUN = function(x) {
if(!require(x, character.only = TRUE)){
  devtools::install_github("JinmiaoChenLab/Rphenograph")
  library(x,character.only = TRUE)
}

})

theme_set(theme_cowplot())
```

```{r setting_up, include=FALSE}
# message
message("Rendering Dashboard")

# reading data
dat_seg <- readr::read_tsv(fs::dir_ls(path = paste0(here(),"/",params$outdir), recurse = T, glob= "*uber*seg.txt")) %>% janitor::clean_names()
dat_seg_cp <- dat_seg %>% dplyr::select(-chrom, -chrompos, -abspos)

dat_bin <- readr::read_tsv(fs::dir_ls(path = paste0(here(),"/",params$outdir), recurse = T, glob= "*uber*bin.txt")) %>% janitor::clean_names()
dat_stats <- readr::read_tsv(fs::dir_ls(path = paste0(here(),"/",params$outdir), recurse = T, regex= "all_stat_metrics.txt")) %>% 
  janitor::clean_names() %>% 
  mutate(duplicates = dups_removed/total_reads)

# correcting names
dat_stats$sample_name <- make_clean_names(dat_stats$sample_name)
Raw_dat_stats<-dat_stats
dat_stats <- dat_stats %>%
  dplyr::filter(sample_name %in% names(dat_seg))
dat_stats_rm<-Raw_dat_stats %>% dplyr::filter(!sample_name %in% names(dat_seg))

# dat_stats metrics
dat_stats_metrics <- dat_stats %>% 
  dplyr::select(-sample_name) %>% 
  summarise_all(median)

# reading ratio
dat_rat <- readr::read_tsv(fs::dir_ls(path = paste0(here(),"/",params$outdir), recurse = T, glob= "*uber*ratio.txt")) %>% 
  janitor::clean_names()
dat_rat_cp <- dat_rat %>% dplyr::select(-chrom, -chrompos, -abspos)

# dat_seg setup
dat_seg_s <- dat_seg %>% 
  dplyr::select(-chrom, -chrompos, - abspos)

dat_seg_t <- as.data.frame(t(dat_seg_s))

# n cells
n_cells <- dat_seg %>% 
  dplyr::select(-abspos, 
                -chrompos, 
                -chrom) %>% 
  ncol()

# sourcing integer inference
source(paste(params$directory, "/integer_cn.R", sep = ""))
```

```{r clustering, include = FALSE}
if (n_cells < 30) {
  umap_n_neighbors <- n_cells - 1
} else umap_n_neighbors <- 30

set.seed(42)
dat_umap <- uwot::umap(dat_seg_t, 
                       metric = "manhattan",
                       n_threads = 20,
                       min_dist = 0,
                       n_neighbors = umap_n_neighbors)
  
umap_df <- as.data.frame(dat_umap) %>% 
  dplyr::rename("umap1" = "V1",
                "umap2" = "V2")
rownames(umap_df) <- rownames(dat_seg_t)

if (n_cells < 30) {
  k_param <- n_cells - 1
} else k_param <- 30
  
pheno <- Rphenograph::Rphenograph(umap_df, k = k_param)
cl <- tibble(cell = rownames(umap_df),
             cluster = igraph::membership(pheno[[2]])) %>% 
  arrange(cluster)

umap_df <- umap_df[cl$cell,]

# getting number of needed colors for cl
n_colors <- cl$cluster %>% unique() %>% length()

# ordering cells
dat_seg_order <- dat_seg_t[cl$cell,]

# setting colors
row_col <- setNames(colorRampPalette(paletteer_d(pals, 
                                alphabet, 26))(n_colors),
                    levels(as.factor(cl$cluster)))
```

Summary
=======================================================================

Column {data-width=200}
-----------------------------------------------------------------------

### Cells Sequenced {.colored}

```{r}
 Raw_dat_stats%>% 
  nrow() %>% 
  valueBox(icon = "circle")
```

### Cells Analysed {.colored}

```{r}
dat_seg %>% 
  dplyr::select(-chrom, -chrompos, -abspos) %>% 
  ncol() %>% 
  valueBox(icon = "circle")
```

### Total Reads (Median) {.colored}

```{r tot_reads_val_box}
dat_stats_metrics$total_reads %>% 
  valueBox(icon = "percentage")
```

### Kept Reads (Median) {.colored}

```{r kep_reads_val_box}
dat_stats_metrics$reads_kept %>% 
  valueBox(icon = "percentage")
```

### Bin Count (Median) {.colored}

```{r bincount_val_box}
dat_stats_metrics$median_bin_count %>% 
  valueBox(icon = "percentage")
```

### PCR Duplicates (Median) {.colored}

```{r calculating_pcr_duplicates}
dups <- round(dat_stats_metrics$duplicates*100,2)
valueBox(paste0(dups,"%"))
```

### Clusters
```{r n_clusters}
cl$cluster %>% unique() %>% length() %>% 
  valueBox()
```

Column
-----------------------------------------------------------------------

### Heatmap 

```{r making_heatmap, fig.height=9}
# chromosome annotation top bar
# getting the vector of chrom lengths
chr_lengths <- dat_seg %>% 
  dplyr::select(abspos, chrom, chrompos) %>% 
  group_by(chrom) %>%
  summarize(n = n()) %>%
  pull(n)

chr_binary <- rep(c(2,1), 12)
chr <- data.frame(chr = rep.int(x = chr_binary, times = chr_lengths))
# getting lengths for chr numbers annotation
chr_rl_c <- c(1, cumsum(chr_lengths))
# creating a data frame to calculate rowMeans
chr_df <-  data.frame(a = chr_rl_c[1:length(chr_rl_c)-1],b= chr_rl_c[2:length(chr_rl_c)])
chr_l_means <- round(rowMeans(chr_df))
chrom.names <- c(1:22,"X", "Y")
# creating the vector for chr number annotations
v <- vector(mode = "character",length = cumsum(chr_lengths)[length(chr_lengths)])
v[chr_l_means] <- chrom.names
v[is.na(v)] <- ""
chr_bar <- HeatmapAnnotation(chr_text = anno_text(v, 
                                                  gp = gpar(fontsize = 8)),
                             df = chr,
                             show_legend = FALSE,
                             which = "column",
                             col = list(chr = c("1" = "grey88", "2" = "black"))
)

heat_row_col <- rowAnnotation(df =
  data.frame(clusters = sort(cl$cluster)),
             col = list(clusters = row_col))

ht <- Heatmap(as.matrix(log2(dat_seg_order+1e-3)),
              cluster_columns = FALSE,
              cluster_rows = FALSE,
              show_row_names = FALSE,
              show_column_names = FALSE,
              use_raster = TRUE,
              top_annotation = chr_bar,
              heatmap_legend_param = list(title = "Log2 (Ratio)"))

draw(heat_row_col + ht)
```


Column 
-----------------------------------------------------------------------

### UMAP. Hover mouse for more info. {data-height=500}

```{r generating_umap}
p_umap <- umap_df %>% 
  rownames_to_column(var = "Cell") %>%
  dplyr::mutate(cluster = cl$cluster) %>% 
  ggplot() +
  geom_point(aes(x = umap1, 
                 y = umap2, 
                 color = as.factor(cluster),
                 label = Cell),
             show.legend = FALSE) +
  scale_color_manual(values = row_col) +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        axis.line = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank()) 

ggplotly(p_umap, tooltip = "Cell")
```


### Ploidy Inference. Hover mouse for more info. {data-height=500}

```{r infering_ploidies}
dat_ploidy <- Reduce(rbind, 
                     parallel::mcmapply(function(prof, name) c(name, ploidy.and.peakheight(prof)),
                                        dat_rat_cp, names(dat_rat_cp),
                                        mc.cores= 40, SIMPLIFY=FALSE)) %>% 
  as_tibble() %>% 
  readr::type_convert() %>% 
  dplyr::rename(sample_name = V1) %>% 
  dplyr::mutate(Cell = paste(sample_name, 
                              ": ", 
                              ploidy,
                              sep = ""))

# obtaining clusters labels to use as colors, matching with cell name and plotting
umap_cl_result <- umap_df %>% rownames_to_column("sample_name") %>%  mutate(cluster = cl$cluster) %>% dplyr::select(sample_name, cluster) 

dat_ploidy_cl <- inner_join(dat_ploidy,umap_cl_result, by = "sample_name")

p_ploidy <- ggplot(dat_ploidy_cl) + 
  geom_point(aes(x = ploidy, 
                 y = peak_height, 
                 color = as.factor(cluster),
                 label = Cell)) +
  scale_color_manual(values = row_col) + 
  scale_x_continuous(breaks = scales::pretty_breaks()) +
  scale_y_continuous(breaks = scales::pretty_breaks()) +
  xlab("Inferred ploidy") +
  ylab("Peak Height (Confidence)") + 
  labs(color = "Cluster")

ggplotly(p_ploidy, tooltip = "Cell")
```

QC
=======================================================================

Row {.tabset .tabset-fade data-width=400}
-----------------------------------------------------------------------

### Quality
```{r}
message("Calculating RMSE")

rmses <- vector()

for (i in 4:ncol(dat_seg)) {
  actual <- dat_seg[, i] %>% pull()
  predicted <- dat_rat[, i] %>% pull()

  rmses[i] <- rmse(actual, predicted)
  names(rmses)[i] <- names(dat_seg[, i]) 
}

rmses_df <- enframe(rmses,
  name = "sample_name",
  value = "rmse"
)

# cv
message("Calculating CV")
cv <- vector()

for(i in 4:ncol(dat_seg)) {
  seg_n_probes <- rle(pull(dat_seg[,i]))$lengths
  ratio_split <- split(pull(dat_rat[,i]), 
                       as.factor(rep.int(1:length(seg_n_probes), seg_n_probes)))
  cv[i] <- lapply(ratio_split, function(x) sd(x)/mean(x)) %>% unlist() %>% sum()
  names(cv)[i] <- names(dat_seg[,i])
}

cv_df <- enframe(cv,
                      name = "sample_name",
                      value = "cv"
)

cv_rmse_df <- inner_join(rmses_df, cv_df)

p <- cv_rmse_df %>% 
  ggplot(aes(cv, rmse)) +
  geom_point(aes(label = sample_name)) +
  geom_smooth(method = "lm") +
  scale_color_viridis_d() +
  scale_x_continuous(breaks = scales::pretty_breaks(n = 10)) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 10)) +
  xlab("Coefficient of Variation") + 
  ylab("RMSE")

p <- ggplotly(p)

p_rmse <- inner_join(dat_stats, cv_rmse_df) %>% 
  ggplot(aes(reads_kept, rmse)) + 
  geom_point() +
  geom_smooth() +
  scale_x_continuous(breaks = scales::pretty_breaks(n = 10)) + 
  scale_y_continuous(breaks = scales::pretty_breaks(n = 10)) + 
  scale_color_viridis_c(option = "inferno") +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab("RMSE")
  

p_rmse <- ggplotly(p_rmse)

subplot(p,p_rmse,
        nrows = 2,
        titleX = TRUE,
        titleY = TRUE)

```

### Duplicates 

```{r}
# creates a index for x and y so I have a square matrix, also creates a lable for plotly
p_dups <- dat_stats %>% 
  mutate(idx_x = rep(1:sqrt(nrow(dat_stats)), 
                     length.out = nrow(dat_stats), 
                     each = sqrt(nrow(dat_stats)))) %>%
  mutate(idx_y = rep(paste(1:sqrt(nrow(dat_stats)),"a", sep = ""),
                     length.out = nrow(dat_stats)))  %>% 
  dplyr::mutate(Cell = paste(sample_name,
                              "- Duplicates: ",
                             scales::percent(duplicates),
                             sep = "")) %>% 
  ggplot() + 
  geom_tile(aes(x = idx_x, 
                y = idx_y, 
                fill = duplicates,
                label = Cell)) +
  coord_equal() + 
  scale_fill_viridis_c(option = "viridis",
                       labels = scales::percent) +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank()) +
  ylab("") +
  xlab("") 


# ggplotly
p_dups
# ggplotly(p_dups, tooltip = "Cell") 
```

### Bin count

```{r}
dat_bin %>% 
  dplyr::select(-chrom, -chrompos, -abspos) %>% 
  purrr::map_dfr(median) %>% 
  gather(key = "cell",
         value = "bin_median") %>% 
  dplyr::filter(bin_median > 1) %>% 
  ggplot() +
  geom_histogram(aes(x = bin_median, 
                     y= ..count../sum(..count..)),
                 fill = "white",
                 color = "black") +
  xlab("GC normalized median bin count") +
  ylab("Frequency")
```

### Reads

```{r}
dat_stats %>% 
  gather(key = "parameter",
         value = "value",
         -sample_name) %>% 
  dplyr::filter(parameter %in% c("total_reads", "reads_kept"),
                value > 500) %>% 
  ggplot() +
  geom_histogram(aes(x = value,
                     y = ..count../sum(..count..),
                     fill = parameter),
                 color = "black") +
  facet_wrap(vars(parameter)) +
  scale_fill_manual(values = c("#7D3232", "#32324B")) +
  scale_x_continuous(breaks = scales::pretty_breaks(n = 7)) +
  theme(axis.text.x = element_text(angle = 90),
        strip.background = element_rect(fill= NA),
        legend.position = "none") +
  xlab("Reads") +
  ylab("Frequency")
```

Row {.tabset .tabset-fade .tabset-pills}
-----------------------------------------------------------------------

### Reads information

```{r}
dt_dat_stats <- dat_stats %>% 
  arrange(desc(reads_kept)) %>% 
  mutate(duplicates = scales::percent(round(duplicates,2)))

DT::datatable(dt_dat_stats, options = list(pageLength = 50))
```

### Removed cells information
```{r}
dt_dat_stats_rm <- dat_stats_rm %>% 
  arrange(desc(reads_kept)) %>% 
  mutate(duplicates = scales::percent(round(duplicates,2)))

DT::datatable(dt_dat_stats_rm, options = list(pageLength = 50))
```

Example Profiles
=======================================================================
```{r making_ratio_plots}
### making the plots 

packages <- c("tidyverse", "here", "parallel", "fs", "janitor", "pals")
# if a package is installed, it will be loaded
# if any are not, the missing package(s) will be installed and loaded
package.check <- lapply(packages, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    install.packages(x, dependencies = TRUE)
    library(x, character.only = TRUE)
  }
})


# reading ratio
dat_rat_cp <- dat_rat %>% dplyr::select(-chrom, -chrompos, -abspos)
dat_seg_cp <- dat_seg %>% dplyr::select(-chrom, -chrompos, -abspos)

# saving the median
# filtering errors of ploidy (I'm considering 1 calls as error)
dat_ploidy_filtered <- dat_ploidy %>% 
  dplyr::filter(ploidy != 1)
ploidy_median <- median(dat_ploidy_filtered$ploidy)

# establishing a value to truncate the ploidy that will be used for the colors later
ploidy_trunc_val <- round(ploidy_median) * 2

# Creating absolute position of chromosomes, code slighly modified from Alex's ggplot CNV heatmap
chrom.lengths <-
  c(
    249250621,
    243199373,
    198022430,
    191154276,
    180915260,
    171115067,
    159138663,
    146364022,
    141213431,
    135534747,
    135006516,
    133851895,
    115169878,
    107349540,
    102531392,
    90354753,
    81195210,
    78077248,
    59128983,
    63025520,
    48129895,
    51304566,
    155270560,
    59373566
  )
chrom.names <- c(paste("chr", 1:22, sep = ""),
                 "chrX",
                 "chrY")
chrom.abspos.end <- cumsum(chrom.lengths)
names(chrom.abspos.end) <- chrom.names
chrom.abspos.start <-
  c(0, chrom.abspos.end[1:(length(chrom.abspos.end) - 1)])
names(chrom.abspos.start) <- names(chrom.abspos.end)

# Creating data frame object for chromosome rectangles shadows
chrom.rects <- data.frame(xstart = chrom.abspos.start,
                          xend = chrom.abspos.end)
xbreaks <- rowMeans(chrom.rects)
chrom.rects$colors <-rep(c("white", "gray"), 12)

#storing chromosomes info
chrom_info <- dat_bin %>% dplyr::select(c(abspos,chrom, chrompos))

# removing chromosomes info to calculate the ratios
bin_data_cp <- dat_bin %>% dplyr::select(-c(abspos,chrom, chrompos))
ratios_data <- sweep(bin_data_cp, 2, apply(bin_data_cp, 2, mean), '/')

# removing chromosomes info from seg_data
dat_seg_cp <- dat_seg %>% dplyr::select(-chrom, -chrompos)

# adding chromosomes info back
ratios_data$abspos <- chrom_info$abspos

# ggplot will need the long format tables, using gather
ratios_data_l_gat <- tidyr::gather(data = ratios_data %>% dplyr::select(1:ncol(bin_data_cp), abspos), key = "cell", value = "ratios_rat", -abspos)
long_seg_t_gat <- tidyr::gather(data = dat_seg_cp %>% dplyr::select(1:ncol(bin_data_cp), abspos), key = "cell", value = "seg_mean", -abspos)

# I'll need to join both tables
df <- inner_join(ratios_data_l_gat, long_seg_t_gat)
# ploidy scaling the seg values
df <- df %>% dplyr::mutate(int_value = round(ploidy_median*seg_mean))

# obtaining the max value. I'll use later on the plot
max_int_value <- max(df$int_value)
# truncating so I can limit the colors
df$int_value[df$int_value > ploidy_trunc_val] <- ploidy_trunc_val

# setting colors of the ratios according to the inferred ploidy
ratio_colors <- structure(
  pals::ocean.balance(length(0:ploidy_trunc_val)),
  names = 0:ploidy_trunc_val
)
# saving the names of the cells so I can iterate later
cell_names <- df$cell %>% unique()

#chromosomes squares background
ggchr.back <-
  list(geom_rect(
    data = chrom.rects,
    aes(
      xmin = xstart,
      xmax = xend,
      ymin = -Inf,
      ymax = Inf,
      fill = colors
    ),
    alpha = .2
  ), scale_fill_identity()) 

sec_breaks <- c(0, 0.5e9, 1e9, 1.5e9, 2e9, 2.5e9, 3e9)
sec_labels <- c(0, 0.5, 1, 1.5, 2, 2.5, 3)

ggaes <- list(
  scale_x_continuous(breaks = xbreaks,
                     labels = gsub("chr", "", chrom.names),
                     position = "top",
                     expand = c(0,0),
                     sec.axis = sec_axis(~., breaks = sec_breaks, labels = sec_labels, name = "Genome Position (Gb)")),
  theme_classic(),
  theme(
    axis.text.x = element_text(angle = 0,
                               vjust = .5,
                               size = 8),
    axis.text.y = element_text(size = 8),
    axis.title.y.right = element_text(margin = margin(l = 10)),
    legend.position = "none",
    axis.ticks.x = element_blank(),
    axis.title = element_text(size = 8),
    plot.title = element_text(size = 8),
    axis.text = element_text(size = 8)
  )
)

plots <- invisible(parallel::mclapply(seq_along(cell_names), function (x) {
  # just get the mean to calculate the CN, should be 1 though...
  mean_ratios_cell <- df %>% dplyr::filter(cell == cell_names[x]) %>% pull(ratios_rat) %>% mean()
  
  #getting cell ploidy info
  cell_ploidy_info <- dat_ploidy %>% 
    dplyr::filter(sample_name == cell_names[x])
  
  p <- ggplot(df %>% filter(cell == cell_names[x])) +
    geom_point(aes(abspos, ratios_rat, color = as.factor(int_value)),
               shape = 20,
               size = 1,
               alpha = .7) +
    geom_line(aes(abspos, seg_mean), col = "black",
              size = 1) +
    ggchr.back +
    ggaes +
    xlab("") +
    ylab("ratios") +
    ggtitle(paste(toupper(cell_ploidy_info$sample_name),
                  " Inferred ploidy: ", 
                  round(cell_ploidy_info$ploidy,2),
                  " - Confidence: ",
                  round(cell_ploidy_info$peak_height,2), sep = "")) +
    scale_y_continuous(sec.axis = sec_axis(~.*cell_ploidy_info$ploidy/mean_ratios_cell, breaks = seq(0,max_int_value,1), name  = "Copy Number"), 
                       name = "Ratios") +
    scale_color_manual(values = ratio_colors) +
    theme(plot.title = element_text(size = 7),
          axis.title = element_text(size = 7),
          axis.text = element_text(size = 7))
  
  return(p)
}
, mc.cores = 20)
)
```

Row {.tabset .tabset-fade}
-----------------------------------------------------------------------

### 1-2
```{r}
cowplot::plot_grid(plotlist = plots[1:2], ncol = 1)
```

### 3-4
```{r}
cowplot::plot_grid(plotlist = plots[3:4], ncol = 1)
```

### 5-6
```{r}
cowplot::plot_grid(plotlist = plots[5:6], ncol = 1)
```

### 7-8
```{r}
cowplot::plot_grid(plotlist = plots[7:8], ncol = 1)
```

### 9-10
```{r}
cowplot::plot_grid(plotlist = plots[9:10], ncol = 1)
```

### 11-12
```{r}
cowplot::plot_grid(plotlist = plots[11:12], ncol = 1)
```

### 13-14
```{r}
cowplot::plot_grid(plotlist = plots[13:14], ncol = 1)
```

### 15-16
```{r}
cowplot::plot_grid(plotlist = plots[15:16], ncol = 1)
```

### 17-18
```{r}
cowplot::plot_grid(plotlist = plots[17:18], ncol = 1)
```

### 19-20
```{r}
cowplot::plot_grid(plotlist = plots[19:20], ncol = 1)
```

### 21-22
```{r}
cowplot::plot_grid(plotlist = plots[21:22], ncol = 1)
```

### 23-24
```{r}
cowplot::plot_grid(plotlist = plots[23:24], ncol = 1)
```

### 25-26
```{r}
cowplot::plot_grid(plotlist = plots[25:26], ncol = 1)
```

### 27-28
```{r}
cowplot::plot_grid(plotlist = plots[27:28], ncol = 1)
```

### 29-30
```{r}
cowplot::plot_grid(plotlist = plots[29:30], ncol = 1)
```

### 31-32
```{r}
cowplot::plot_grid(plotlist = plots[31:32], ncol = 1)
```

### 33-34
```{r}
cowplot::plot_grid(plotlist = plots[33:34], ncol = 1)
```

### 35-36
```{r}
cowplot::plot_grid(plotlist = plots[35:36], ncol = 1)
```

### 37-38
```{r}
cowplot::plot_grid(plotlist = plots[37:38], ncol = 1)
```

### 39-40
```{r}
cowplot::plot_grid(plotlist = plots[39:40], ncol = 1)
```

### 41-42
```{r}
cowplot::plot_grid(plotlist = plots[41:42], ncol = 1)
```

### 43-44
```{r}
cowplot::plot_grid(plotlist = plots[43:44], ncol = 1)
```

### 45-46
```{r}
cowplot::plot_grid(plotlist = plots[45:46], ncol = 1)
```

### 47-48
```{r}
cowplot::plot_grid(plotlist = plots[47:48], ncol = 1)
```

Phylogenetics
=======================================================================

Row
-----------------------------------------------------------------------

### Neighbor-Joining tree

```{r running_phylogenetics}
tree <- ape::nj(
  amap::Dist(dat_seg_order, 
             method = "manhattan", 
             nbproc = 40)
)

# obtaining colors
list_samples <- split(rownames(dat_seg_order),
                      sort(cl$cluster))
tree <- ggtree::groupOTU(tree, list_samples) 

ggtree(ladderize(tree),
  ladderize = FALSE,
  size = .1) +
  geom_tippoint(aes(color = group), size = .7) +
  scale_colour_manual(values = c("black", row_col)) +
  theme(legend.position = "right") +
  labs(color = "Cluster")
```

About
=======================================================================

Row
-----------------------------------------------------------------------

### Dashboard
This dashboard was developed by Darlan Conterno Minussi and is a part of the Navin Lab copy number pipeline.

### Clustering
Clustering of the data is being performed with UMAP dimension reduction followed by R phenograph.

UMAP is using the following parameters:

- Seed: 42
- Distance: Manhattan
- min_dist: 0
- n_neighbors: 30 (if n_cells < 30 then k = n_cells - 1)

RPhenograph is using the following parameters:

- k: 30 (if n_cells < 30 then k = n_cells - 1)

### Ploidy Inference
Ploidy inference is using the fourier transform method developed by Alexander Davis. For more information please refer to the following publication.
Ref: Soon

### Phylogenetics
Phylogenetics is using the Neighbor-Joining method and the distance matrix is calculated using manhattan distance.

Row
-----------------------------------------------------------------------

### Packages
The following packages were used in this dashboard:

- flexdashboard
- tidyverse
- here
- fs
- cowplot
- DT
- shiny
- janitor
- ape
- ggtree
- ggsci
- plotly
- amap
- paletteer
- scales
- uwot
- dbscan
- ComplexHeatmap
- flsa
- Rphenograph

