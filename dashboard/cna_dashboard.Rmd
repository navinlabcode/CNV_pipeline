---
title: "CNA dashboard"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
    theme: default
    logo: navin_lab_logo.png
---

```{r setup, include=FALSE, message=FALSE}
# checking for packages, loading or installing
packages <- c("tidyverse", "fs", "shiny",
              "here", "flexdashboard", "cowplot",
              "janitor", "ape", "ggsci", "plotly",
              "amap", "paletteer", "scales", "umap", "dbscan",
              "flsa", "BiocManager")

package.check <- lapply(packages, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    install.packages(x, dependencies = TRUE)
    library(x, character.only = TRUE)
  }
})

bioc_packages <- c("ggtree", "ComplexHeatmap")

lapply(bioc_packages, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    BiocManager::install(x, update = FALSE)
    library(x, character.only = TRUE)
  }
})

```

```{r, include=FALSE}
# message
message("Rendering Dashboard")

# reading data
dat_seg <- readr::read_tsv(fs::dir_ls(path = here(), recursive = T, glob= "*uber*seg.txt"))
dat_bin <- readr::read_tsv(fs::dir_ls(path = here(), recursive = T, glob= "*uber*bin.txt"))
dat_stats <- readr::read_tsv(fs::dir_ls(path = here(), recursive = T, regex= "all_stat_metrics.txt")) %>% 
  janitor::clean_names() %>% 
  mutate(duplicates = dups_removed/total_reads)

# reading ratio
dat_rat <- readr::read_tsv(fs::dir_ls(path = here(), recursive = T, glob= "*uber*ratio.txt"))
dat_rat_cp <- dat_rat %>% dplyr::select(-chrom, -chrompos, -abspos)

# dat_seg setup
dat_seg_s <- dat_seg %>% 
  dplyr::select(-chrom, -chrompos, - abspos)

dat_seg_t <- as.data.frame(t(dat_seg_s))

# n cells
n_cells <- dat_seg %>% 
  dplyr::select(-abspos, 
                -chrompos, 
                -chrom) %>% 
  ncol()

# sourcing integer inference
source(here::here("bin", "integer_cn.R"))
```

```{r umap_snn, include = FALSE}
dat_umap <- umap::umap(dat_seg_t, random_state= 42, metric = "euclidean")
  
umap_df <- data.frame(umap1 = dat_umap$layout[,1],
                        umap2 = dat_umap$layout[,2])

if (n_cells < 15) {
  snn_k_param <- n_cells - 1
} else snn_k_param <- 15
  
cl <- dbscan::sNNclust(umap_df, k = snn_k_param, eps = 2, minPts = 5)

# ordering cells
dat_seg_order <- dat_seg_t[order(cl$cluster),]

# setting colors
row_col <- setNames(paletteer_d(ggsci, 
                                nrc_npg, 
                                length(levels(as.factor(cl$cluster)))),
                    levels(as.factor(cl$cluster)))
```

Summary
=======================================================================

Row
-----------------------------------------------------------------------

### Cells

```{r}
dat_seg %>% 
  dplyr::select(-chrom, -chrompos, -abspos) %>% 
  ncol() %>% 
  valueBox(icon = "circle")
```

### Median PCR Duplicates

```{r}
median(dat_stats$duplicates) %>% 
  scales::percent() %>% 
  valueBox(icon = "percentage")
```


### UMAP. Hover mouse for more info.

```{r}
p_umap <- umap_df %>% 
  rownames_to_column(var = "Cell") %>%
  dplyr::mutate(cluster = cl$cluster) %>% 
  dplyr::mutate(Cell = str_extract(Cell, "^[^_]*")) %>% 
  ggplot() +
  geom_point(aes(x = umap1, 
                 y = umap2, 
                 color = as.factor(cluster),
                 label = Cell),
             show.legend = FALSE) +
  scale_color_npg() +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        axis.line = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank()) 

ggplotly(p_umap, tooltip = "Cell")
```

Row
-----------------------------------------------------------------------

### Heatmap {data-height=650}

```{r}
# chromosome annotation top bar
# loading data containing vector chr
chr_lengths <- c(953, 1038,  875,  838,  782,  724,  646,  635,  480,  561,  568,  575,  431,  391,  332,  310,  311,  336,  220, 266,  149 , 139,  607,   38)
chr_binary <- rep(c(2,1), 12)
chr <- data.frame(chr = rep.int(x = chr_binary, times = chr_lengths))
# getting lengths for chr numbers annotation
chr_rl_c <- c(1, cumsum(chr_lengths))
# creating a data frame to calculate rowMeans
chr_df <-  data.frame(a = chr_rl_c[1:length(chr_rl_c)-1],b= chr_rl_c[2:length(chr_rl_c)])
chr_l_means <- round(rowMeans(chr_df))
chrom.names <- c(1:22,"X", "Y")
# creating the vector for chr number annotations
v <- vector()
v[chr_l_means] <- chrom.names
v[is.na(v)] <- ""
chr_bar <- HeatmapAnnotation(chr_text = anno_text(v, 
                                                  gp = gpar(fontsize = 8)),
                             df = chr,
                             show_legend = FALSE,
                             which = "column",
                             col = list(chr = c("1" = "grey88", "2" = "black"))
)

heat_row_col <- rowAnnotation(
  data.frame(clusters = sort(cl$cluster)),
             col = list(clusters = row_col))

ht <- Heatmap(log2(dat_seg_order+1e-3),
              cluster_columns = FALSE,
              cluster_rows = FALSE,
              show_row_names = FALSE,
              show_column_names = FALSE,
              use_raster = TRUE,
              top_annotation = chr_bar,
              heatmap_legend_param = list(title = "Log2 (Ratio)"))

draw(heat_row_col + ht)
```

### Ploidy Inference. Hover mouse for more info. {data-height=350}

```{r}
dat_ploidy <- Reduce(rbind, 
                     parallel::mcmapply(function(prof, name) c(name, ploidy.and.peakheight(prof)),
                                        dat_rat_cp, names(dat_rat_cp),
                                        mc.cores= 40, SIMPLIFY=FALSE)) %>% 
  as_tibble() %>% 
  readr::type_convert() %>% 
  dplyr::rename(sample_name = V1) %>% 
  dplyr::mutate(sample_name = str_extract(sample_name, "^[^_]*")) %>% 
  dplyr::mutate(Cell = paste(sample_name, 
                              ": ", 
                              ploidy,
                              sep = ""))

p_ploidy <- ggplot(dat_ploidy) + 
  geom_point(aes(x = ploidy, 
                 y = peak_height, 
                 color = peak_height,
                 label = Cell)) +
  scale_color_paletteer_c(scico, berlin) + 
  scale_x_continuous(breaks = scales::pretty_breaks()) +
  scale_y_continuous(breaks = scales::pretty_breaks()) +
  xlab("Inferred ploidy") +
  ylab("Peak Height (Confidence)")

ggplotly(p_ploidy, tooltip = "Cell")
```

QC
=======================================================================

Row
-----------------------------------------------------------------------

### Reads Kept: Hover mouse over cell for info

```{r}
# creates a index for x and y so I have a square matrix, also creates a lable for plotly
p <- dat_stats %>% 
  mutate(idx_x = rep(1:sqrt(nrow(dat_stats)), length.out = nrow(dat_stats), each = sqrt(nrow(dat_stats)))) %>%
  mutate(idx_y = rep(paste(1:sqrt(nrow(dat_stats)),"a", sep = ""), length.out = nrow(dat_stats)))  %>% 
  dplyr::mutate(sample_name = str_extract(sample_name, "^[^_]*")) %>% 
  dplyr::mutate(Cell = paste(sample_name,
                              "- Reads Kept: ",
                             reads_kept,
                             sep = "")) %>% 
  ggplot() + 
  geom_tile(aes(x = idx_x, 
                y = idx_y, 
                fill = reads_kept,
                label = Cell)) +
  coord_equal() + 
  scale_fill_viridis_c(option = "magma",
                       labels = scales::comma) +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank()) +
  ylab("") +
  xlab("") 


# ggplotly
ggplotly(p, tooltip = c("Cell")) 
```

### Duplicates percentage: Hover mouse over cell for info

```{r}
# creates a index for x and y so I have a square matrix, also creates a lable for plotly
p_dups <- dat_stats %>% 
  mutate(idx_x = rep(1:sqrt(nrow(dat_stats)), 
                     length.out = nrow(dat_stats), 
                     each = sqrt(nrow(dat_stats)))) %>%
  mutate(idx_y = rep(paste(1:sqrt(nrow(dat_stats)),"a", sep = ""),
                     length.out = nrow(dat_stats)))  %>% 
  dplyr::mutate(sample_name = str_extract(sample_name, "^[^_]*")) %>% 
  dplyr::mutate(Cell = paste(sample_name,
                              "- Duplicates: ",
                             scales::percent(duplicates),
                             sep = "")) %>% 
  ggplot() + 
  geom_tile(aes(x = idx_x, 
                y = idx_y, 
                fill = duplicates,
                label = Cell)) +
  coord_equal() + 
  scale_fill_viridis_c(option = "viridis",
                       labels = scales::percent) +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank()) +
  ylab("") +
  xlab("") 


# ggplotly
ggplotly(p_dups, tooltip = "Cell") 
```

Row
-----------------------------------------------------------------------

### GC normalized bin read count distribution

```{r}
dat_bin %>% 
  dplyr::select(-chrom, -chrompos, -abspos) %>% 
  purrr::map_dfr(median) %>% 
  gather(key = "cell",
         value = "bin_median") %>% 
  ggplot() +
  geom_histogram(aes(x = bin_median, 
                     y= ..count../sum(..count..)),
                 fill = "white",
                 color = "black") +
  xlab("GC normalized median bin count") +
  ylab("Frequency")
```

### GC normalized bin read count distribution

```{r}
dat_stats %>% 
  gather(key = "parameter",
         value = "value",
         -sample_name) %>% 
  dplyr::filter(parameter %in% c("total_reads", "reads_kept")) %>% 
  ggplot() +
  geom_histogram(aes(x = value,
                     y = ..count../sum(..count..),
                     fill = parameter),
                 color = "black") +
  facet_wrap(vars(parameter)) +
  scale_fill_manual(values = c("#7D3232", "#32324B")) +
  scale_x_continuous(breaks = scales::pretty_breaks(n = 7)) +
  theme(axis.text.x = element_text(angle = 90),
        strip.background = element_rect(fill= NA),
        legend.position = "none") +
  xlab("Reads") +
  ylab("Frequency")
```

Phylogenetics
=======================================================================

Row
-----------------------------------------------------------------------

### Neighbor-Joining tree

```{r}
tree <- ape::nj(
  amap::Dist(dat_seg_order, 
             method = "manhattan", 
             nbproc = 40)
)

# obtaining colors
list_samples <- split(rownames(dat_seg_order),
                      sort(cl$cluster))
tree <- ggtree::groupOTU(tree, list_samples) 

ggtree(ladderize(tree),
  ladderize = FALSE,
  size = .1) +
  geom_tippoint(aes(color = group), size = .7) +
  scale_colour_manual(values = c("black", row_col)) +
  theme(legend.position = "right") +
  labs(color = "SNN Cluster")
```

About
=======================================================================

Row
-----------------------------------------------------------------------

### Dashboard
This dashboard was developed by Darlan Conterno Minussi and is a part of the Navin Lab copy number pipeline.

### Clustering
Clustering of the data is being performed with UMAP dimension reduction followed by SNN clustering.

UMAP is using the following parameters:

- Seed: 42
- Distance: Euclidean

SNN is using the following parameters:

- k: 15 (if n_cells < 15 then k = n_cells - 1)
- eps: 2
- minPts: 5

### Ploidy Inference
Ploidy inference is using the fourier transform method developed by Alexander Davis. For more information please refer to the following publication.
Ref: Soon

### Phylogenetics
Phylogenetics is using the Neighbor-Joining method and the distance matrix is calculated using manhattan distance.

Row
-----------------------------------------------------------------------

### Packages
The following packages were used in this dashboard:

- flexdashboard
- tidyverse
- here
- fs
- cowplot
- shiny
- janitor
- ape
- ggtree
- ggsci
- plotly
- amap
- paletteer
- scales
- umap
- dbscan
- ComplexHeatmap
- flsa

